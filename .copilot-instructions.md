# Copilot Instructions for "Eat My Entire Ass" Game

This repository contains a Blazor WebAssembly game with an Azure Functions backend. Follow these guidelines when writing code for this project.

## Architecture Overview

- **Client**: Blazor WebAssembly frontend (.NET 9.0)
- **Api**: Azure Functions backend (.NET 9.0) 
- **Shared**: Common models and utilities (.NET 9.0)
- **Deployment**: Azure Static Web Apps

## Code Style Guidelines

### C# Conventions

- Use **PascalCase** for classes, methods, properties, and public fields
- Use **camelCase** for local variables and private fields
- Use **PascalCase** for enum values
- Prefer `var` when the type is obvious from context
- Use file-scoped namespaces: `namespace BlazorApp.Client;`
- Enable nullable reference types and handle nullability explicitly

### Blazor Component Guidelines

- **Component Naming**: Use PascalCase for component names (e.g., `AssImageDisplay.razor`)
- **Component Structure**: Keep components focused on a single responsibility
- **Scoped CSS**: Use `.razor.css` files for component-specific styling
- **Parameters**: Use `[Parameter]` attribute and PascalCase for component parameters
- **Event Callbacks**: Use `EventCallback<T>` for parent-child communication

Example component structure:
```razor
@* ComponentName.razor *@
<div class="component-wrapper">
    <!-- Component content -->
</div>

@code {
    [Parameter] public string Title { get; set; } = string.Empty;
    [Parameter] public EventCallback<string> OnValueChanged { get; set; }
    
    private async Task HandleClick()
    {
        await OnValueChanged.InvokeAsync("value");
    }
}
```

### Asset Management Patterns

- Use enums for type safety (follow `AssTypeEnum` pattern)
- Store asset configurations in static dictionaries
- Organize assets by logical groupings
- Use consistent naming for asset files (e.g., `entire_ass.png`, `chunk1.png`)

### JavaScript Interop

- Use `IJSRuntime` for JavaScript interactions
- Wrap JS calls in try-catch blocks
- Prefer async operations: `InvokeAsync<T>()`
- Use meaningful method names for JS functions

### State Management

- Use `ILocalStorageService` for client-side persistence
- Implement proper async/await patterns for storage operations
- Consider using nullable types for optional stored values
- Use meaningful keys for storage: `$"{username}_assesEaten"`

## UI/UX Guidelines

### Bootstrap Usage

- Use Bootstrap 5 classes for layout and styling
- Prefer utility classes over custom CSS when possible
- Use responsive breakpoints: `col-12 col-md-6 col-lg-4`
- Implement mobile-first responsive design

### CSS Conventions

- Use scoped CSS (`.razor.css`) for component-specific styles
- Follow BEM methodology for custom CSS classes when needed
- Use CSS custom properties for theming
- Avoid `!important` unless absolutely necessary

### Component Patterns

- **Modals**: Extend `BSModal` base component for consistent modal behavior
- **Navigation**: Use centralized navigation component (`Navbar.razor`)
- **Game Elements**: Follow the `AssImageDisplay` pattern for interactive game components

## Security Practices

### Data Validation

- Always validate user inputs on both client and server
- Use data annotations for model validation
- Sanitize any user-generated content before storage or display

### API Security

- Use appropriate authorization levels for Azure Functions
- Validate all API inputs
- Never expose sensitive data in client-side code
- Use HTTPS for all communications

### Prohibited Patterns

- **Never** store sensitive data in localStorage
- **Avoid** direct DOM manipulation; use Blazor's declarative approach
- **Don't** use `innerHTML` or similar XSS-prone methods
- **Never** trust client-side validation alone

## Testing Guidelines

### Unit Testing (when implementing)

- Test business logic in isolation
- Mock external dependencies (localStorage, JSRuntime)
- Use descriptive test method names: `GetPointsForAssType_WithGoldenType_Returns10Points()`
- Follow Arrange-Act-Assert pattern

### Component Testing

- Test component rendering with different parameter combinations
- Verify event callbacks are triggered correctly
- Test responsive behavior across breakpoints

## Documentation Standards

### Code Comments

- Use XML documentation for public APIs
- Comment complex business logic
- Explain non-obvious algorithms or calculations
- Document component parameters and their purposes

### README Updates

- Keep deployment instructions current
- Document any new environment variables or configuration
- Update technology versions when upgrading

## Azure Functions Best Practices

### Function Structure

- Keep functions focused on single responsibilities
- Use dependency injection for services
- Return appropriate HTTP status codes
- Handle exceptions gracefully with proper logging

### Performance

- Use async/await patterns consistently
- Minimize cold start times
- Cache frequently accessed data appropriately
- Consider function timeout limits

## Game-Specific Guidelines

### Asset Management

- Follow the established pattern for adding new asset types
- Maintain consistency in asset naming and organization
- Update point values and game mechanics thoughtfully
- Ensure sound files are optimized for web delivery

### Game Mechanics

- Use consistent timing patterns for animations
- Implement proper game state management
- Handle edge cases (game end, timer expiry, etc.)
- Ensure accessibility for interactive elements

### Performance Considerations

- Optimize image assets for web delivery
- Implement proper cleanup for timers and event handlers
- Use efficient rendering patterns for frequent updates
- Consider preloading critical assets

## Common Anti-Patterns to Avoid

1. **Heavy Components**: Break down large components into smaller, reusable pieces
2. **Direct State Mutation**: Use proper state management patterns
3. **Memory Leaks**: Dispose of timers, event handlers, and subscriptions
4. **Blocking Operations**: Always use async patterns for I/O operations
5. **Hardcoded Values**: Use configuration or constants for magic numbers

## Environment Considerations

- **Development**: Use local settings and development configurations
- **Production**: Ensure proper error handling and logging
- **Azure Static Web Apps**: Follow deployment requirements and limitations
- **Browser Compatibility**: Test across modern browsers, consider polyfills if needed

## Version Control Practices

- Use meaningful commit messages
- Keep commits focused and atomic
- Include appropriate `.gitignore` entries for build artifacts
- Tag releases appropriately

Remember: This project has a humorous theme, but maintain professional code quality and security standards throughout development.